Task Description You are a strict code-refactoring engine. You follow all rules exactly as written. Your task is to refactor a Python project by applying the "Replace Nested Conditional with Guard Clauses" pattern to improve readability and reduce cognitive complexity.

Please note:
1. The code must still function perfectly after the refactoring.
2. All imports, references, and function calls must be updated accordingly.
3. The style, formatting, and structure of the code must be preserved.
4. Do not introduce any new functionality, logic changes, or unrelated formatting changes.
5. For every modified file, return the complete updated file content to ensure that no changes are overlooked.
6. The semantics and behavior of the code must not change.
7. Only include files that required changes.
8. Respond with the code blocks only. Your entire response must be machine-readable. Do not include any conversational filler.
9. If you are unsure, do not guess. Only modify code when the change is certain.
10. Every response must include meaningful modifications, improvements, or transformations. Returning the same code, even partially or with superficial edits, is strictly prohibited.
11. Your final output must pass the existing test suite (pytest). If your changes would cause any test to fail, revise your refactor until all tests pass.


Examples: 
Example 1: 
Original Code:
File `example.py`:
```python
def process_order(order):
    if order is not None:
        if order.is_valid():
            if order.has_items():
                return order.calculate_total()
            else:
                return 0
        else:
            return None
    else:
        return None
```

Task Description:
1. Analyze the provided codebase to identify methods containing deeply nested conditional logic (specifically if-else blocks with a nesting depth greater than 2).
2. Evaluate the complexity of these methods and select the two (2) candidates with the highest cognitive complexity or deepest nesting.
3. Refactor these two selected methods by applying the "Replace Nested Conditional with Guard Clauses" pattern. Invert conditional checks to handle edge cases, errors, or "early exits" immediately (using return, continue, break, or raise). Flatten the remaining "happy path" logic to reduce indentation levels.

Output: 
File `example.py`:
```python
def process_order(order):
    if order is None:
        return None
    if not order.is_valid():
        return None
    if not order.has_items():
        return 0
    return order.calculate_total()
```

Example 2:
Originial Code 
File `process.py`:
```python
def process_users(users):
    active_emails = []
    for user in users:
        if user.is_active:
            if user.has_email:
                if not user.is_banned:
                    active_emails.append(user.email)
    return active_emails
```

Task Description:
1. Analyze the provided codebase to identify methods containing deeply nested conditional logic (specifically if-else blocks with a nesting depth greater than 2).
2. Evaluate the complexity of these methods and select the two (2) candidates with the highest cognitive complexity or deepest nesting.
3. Refactor these two selected methods by applying the "Replace Nested Conditional with Guard Clauses" pattern. Invert conditional checks to handle edge cases, errors, or "early exits" immediately (using return, continue, break, or raise). Flatten the remaining "happy path" logic to reduce indentation levels.

Output:
File `process.py`:
```python
def process_users(users):
    active_emails = []
    for user in users:
        # Guard Clause 1: Handle inactive users immediately
        if not user.is_active:
            continue
            
        # Guard Clause 2: Handle users without email immediately
        if not user.has_email:
            continue
            
        # Guard Clause 3: Handle banned users immediately
        if user.is_banned:
            continue
            
        # Happy Path: No indentation needed here
        active_emails.append(user.email)
    return active_emails

```

Task Description:
1. Analyze the provided codebase to identify methods containing deeply nested conditional logic (specifically if-else blocks with a nesting depth greater than 2).
2. Evaluate the complexity of these methods and select the two (2) candidates with the highest cognitive complexity or deepest nesting.
3. Refactor these two selected methods by applying the "Replace Nested Conditional with Guard Clauses" pattern. Invert conditional checks to handle edge cases, errors, or "early exits" immediately (using return, continue, break, or raise). Flatten the remaining "happy path" logic to reduce indentation levels.

For EACH modified file, respond exactly in the following format:

File `filename.py`:
```python
[Complete updated file content]