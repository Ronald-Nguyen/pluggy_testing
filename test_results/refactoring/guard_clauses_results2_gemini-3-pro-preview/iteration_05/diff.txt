--- backup/pluggy\_callers.py
+++ refactored/pluggy\_callers.py
@@ -0,0 +1,132 @@
+from__future__importannotations
+fromcollections.abcimportGenerator
+fromcollections.abcimportMapping
+fromcollections.abcimportSequence
+fromtypingimportcast
+fromtypingimportNoReturn
+fromtypingimportTypeAlias
+importwarnings
+from._hooksimportHookImpl
+from._resultimportHookCallError
+from._resultimportResult
+from._warningsimportPluggyTeardownRaisedWarning
+Teardown:TypeAlias=Generator[None,object,object]
+defrun_old_style_hookwrapper(
+hook_impl:HookImpl,hook_name:str,args:Sequence[object]
+)->Teardown:
+teardown:Teardown=cast(Teardown,hook_impl.function(*args))
+try:
+next(teardown)
+exceptStopIteration:
+_raise_wrapfail(teardown,"didnotyield")
+try:
+res=yield
+result=Result(res,None)
+exceptBaseExceptionasexc:
+result=Result(None,exc)
+try:
+teardown.send(result)
+exceptStopIteration:
+pass
+exceptBaseExceptionase:
+_warn_teardown_exception(hook_name,hook_impl,e)
+raise
+else:
+_raise_wrapfail(teardown,"hassecondyield")
+finally:
+teardown.close()
+returnresult.get_result()
+def_raise_wrapfail(
+wrap_controller:Generator[None,object,object],
+msg:str,
+)->NoReturn:
+co=wrap_controller.gi_code
+raiseRuntimeError(
+f"wrap_controllerat{co.co_name!r}{co.co_filename}:{co.co_firstlineno}{msg}"
+)
+def_warn_teardown_exception(
+hook_name:str,hook_impl:HookImpl,e:BaseException
+)->None:
+msg=(
+f"Apluginraisedanexceptionduringanold-stylehookwrapperteardown.\n"
+f"Plugin:{hook_impl.plugin_name},Hook:{hook_name}\n"
+f"{type(e).__name__}:{e}\n"
+f"Formoreinformationseehttps://pluggy.readthedocs.io/en/stable/api_reference.html#pluggy.PluggyTeardownRaisedWarning"
+)
+warnings.warn(PluggyTeardownRaisedWarning(msg),stacklevel=6)
+def_multicall(
+hook_name:str,
+hook_impls:Sequence[HookImpl],
+caller_kwargs:Mapping[str,object],
+firstresult:bool,
+)->object|list[object]:
+__tracebackhide__=True
+results:list[object]=[]
+exception=None
+try:
+teardowns:list[Teardown]=[]
+try:
+forhook_implinreversed(hook_impls):
+try:
+args=[caller_kwargs[argname]forargnameinhook_impl.argnames]
+exceptKeyErrorase:
+forargnameinhook_impl.argnames:
+ifargnamenotincaller_kwargs:
+raiseHookCallError(
+f"hookcallmustprovideargument{argname!r}"
+)frome
+ifhook_impl.hookwrapper:
+function_gen=run_old_style_hookwrapper(hook_impl,hook_name,args)
+next(function_gen)
+teardowns.append(function_gen)
+continue
+ifhook_impl.wrapper:
+try:
+res=hook_impl.function(*args)
+function_gen=cast(Generator[None,object,object],res)
+next(function_gen)
+teardowns.append(function_gen)
+exceptStopIteration:
+_raise_wrapfail(function_gen,"didnotyield")
+continue
+res=hook_impl.function(*args)
+ifresisnotNone:
+results.append(res)
+iffirstresult:
+break
+exceptBaseExceptionasexc:
+exception=exc
+finally:
+iffirstresult:
+result=results[0]ifresultselseNone
+else:
+result=results
+forteardowninreversed(teardowns):
+try:
+ifexceptionisnotNone:
+try:
+teardown.throw(exception)
+exceptRuntimeErrorasre:
+if(
+isinstance(exception,StopIteration)
+andre.__cause__isexception
+):
+teardown.close()
+continue
+else:
+raise
+else:
+teardown.send(result)
+teardown.close()
+exceptStopIterationassi:
+result=si.value
+exception=None
+continue
+exceptBaseExceptionase:
+exception=e
+continue
+_raise_wrapfail(teardown,"hassecondyield")
+ifexceptionisnotNone:
+raiseexception
+else:
+returnresult

--- backup/pluggy\_manager.py
+++ refactored/pluggy\_manager.py
@@ -0,0 +1,317 @@
+from__future__importannotations
+fromcollections.abcimportCallable
+fromcollections.abcimportIterable
+fromcollections.abcimportMapping
+fromcollections.abcimportSequence
+importinspect
+importtypes
+fromtypingimportAny
+fromtypingimportcast
+fromtypingimportFinal
+fromtypingimportTYPE_CHECKING
+fromtypingimportTypeAlias
+importwarnings
+from.import_tracing
+from._callersimport_multicall
+from._hooksimport_HookImplFunction
+from._hooksimport_Namespace
+from._hooksimport_Plugin
+from._hooksimport_SubsetHookCaller
+from._hooksimportHookCaller
+from._hooksimportHookImpl
+from._hooksimportHookimplOpts
+from._hooksimportHookRelay
+from._hooksimportHookspecOpts
+from._hooksimportnormalize_hookimpl_opts
+from._resultimportResult
+ifTYPE_CHECKING:
+importimportlib.metadata
+_BeforeTrace:TypeAlias=Callable[[str,Sequence[HookImpl],Mapping[str,Any]],None]
+_AfterTrace:TypeAlias=Callable[
+[Result[Any],str,Sequence[HookImpl],Mapping[str,Any]],None
+]
+def_warn_for_function(warning:Warning,function:Callable[...,object])->None:
+func=cast(types.FunctionType,function)
+warnings.warn_explicit(
+warning,
+type(warning),
+lineno=func.__code__.co_firstlineno,
+filename=func.__code__.co_filename,
+)
+classPluginValidationError(Exception):
+def__init__(self,plugin:_Plugin,message:str)->None:
+super().__init__(message)
+self.plugin=plugin
+classDistFacade:
+def__init__(self,dist:importlib.metadata.Distribution)->None:
+self._dist=dist
+@property
+defproject_name(self)->str:
+name:str=self.metadata["name"]
+returnname
+def__getattr__(self,attr:str,default:Any|None=None)->Any:
+returngetattr(self._dist,attr,default)
+def__dir__(self)->list[str]:
+returnsorted(dir(self._dist)+["_dist","project_name"])
+classPluginManager:
+def__init__(self,project_name:str)->None:
+self.project_name:Final=project_name
+self._name2plugin:Final[dict[str,_Plugin]]={}
+self._plugin_distinfo:Final[list[tuple[_Plugin,DistFacade]]]=[]
+self.hook:Final=HookRelay()
+self.trace:Final[_tracing.TagTracerSub]=_tracing.TagTracer().get(
+"pluginmanage"
+)
+self._inner_hookexec=_multicall
+def_hookexec(
+self,
+hook_name:str,
+methods:Sequence[HookImpl],
+kwargs:Mapping[str,object],
+firstresult:bool,
+)->object|list[object]:
+returnself._inner_hookexec(hook_name,methods,kwargs,firstresult)
+defregister(self,plugin:_Plugin,name:str|None=None)->str|None:
+plugin_name=nameorself.get_canonical_name(plugin)
+ifplugin_nameinself._name2plugin:
+ifself._name2plugin.get(plugin_name,-1)isNone:
+returnNone
+raiseValueError(
+"Pluginnamealreadyregistered:"
+f"{plugin_name}={plugin}\n{self._name2plugin}"
+)
+ifplugininself._name2plugin.values():
+raiseValueError(
+"Pluginalreadyregisteredunderadifferentname:"
+f"{plugin_name}={plugin}\n{self._name2plugin}"
+)
+self._name2plugin[plugin_name]=plugin
+fornameindir(plugin):
+hookimpl_opts=self.parse_hookimpl_opts(plugin,name)
+ifhookimpl_optsisNone:
+continue
+normalize_hookimpl_opts(hookimpl_opts)
+method:_HookImplFunction[object]=getattr(plugin,name)
+hookimpl=HookImpl(plugin,plugin_name,method,hookimpl_opts)
+name=hookimpl_opts.get("specname")orname
+hook:HookCaller|None=getattr(self.hook,name,None)
+ifhookisNone:
+hook=HookCaller(name,self._hookexec)
+setattr(self.hook,name,hook)
+elifhook.has_spec():
+self._verify_hook(hook,hookimpl)
+hook._maybe_apply_history(hookimpl)
+hook._add_hookimpl(hookimpl)
+returnplugin_name
+defparse_hookimpl_opts(self,plugin:_Plugin,name:str)->HookimplOpts|None:
+method:object=getattr(plugin,name)
+ifnotinspect.isroutine(method):
+returnNone
+try:
+res:HookimplOpts|None=getattr(
+method,self.project_name+"_impl",None
+)
+exceptException:
+res={}
+ifresisnotNoneandnotisinstance(res,dict):
+res=None
+returnres
+defunregister(
+self,plugin:_Plugin|None=None,name:str|None=None
+)->Any|None:
+ifnameisNone:
+assertpluginisnotNone,"oneofnameorpluginneedstobespecified"
+name=self.get_name(plugin)
+assertnameisnotNone,"pluginisnotregistered"
+ifpluginisNone:
+plugin=self.get_plugin(name)
+ifpluginisNone:
+returnNone
+hookcallers=self.get_hookcallers(plugin)
+ifhookcallers:
+forhookcallerinhookcallers:
+hookcaller._remove_plugin(plugin)
+ifself._name2plugin.get(name):
+assertnameisnotNone
+delself._name2plugin[name]
+returnplugin
+defset_blocked(self,name:str)->None:
+self.unregister(name=name)
+self._name2plugin[name]=None
+defis_blocked(self,name:str)->bool:
+returnnameinself._name2pluginandself._name2plugin[name]isNone
+defunblock(self,name:str)->bool:
+ifself._name2plugin.get(name,-1)isNone:
+delself._name2plugin[name]
+returnTrue
+returnFalse
+defadd_hookspecs(self,module_or_class:_Namespace)->None:
+names=[]
+fornameindir(module_or_class):
+spec_opts=self.parse_hookspec_opts(module_or_class,name)
+ifspec_optsisnotNone:
+hc:HookCaller|None=getattr(self.hook,name,None)
+ifhcisNone:
+hc=HookCaller(name,self._hookexec,module_or_class,spec_opts)
+setattr(self.hook,name,hc)
+else:
+hc.set_specification(module_or_class,spec_opts)
+forhookfunctioninhc.get_hookimpls():
+self._verify_hook(hc,hookfunction)
+names.append(name)
+ifnotnames:
+raiseValueError(
+f"didnotfindany{self.project_name!r}hooksin{module_or_class!r}"
+)
+defparse_hookspec_opts(
+self,module_or_class:_Namespace,name:str
+)->HookspecOpts|None:
+method=getattr(module_or_class,name)
+opts:HookspecOpts|None=getattr(method,self.project_name+"_spec",None)
+returnopts
+defget_plugins(self)->set[Any]:
+return{xforxinself._name2plugin.values()ifxisnotNone}
+defis_registered(self,plugin:_Plugin)->bool:
+returnany(plugin==valforvalinself._name2plugin.values())
+defget_canonical_name(self,plugin:_Plugin)->str:
+name:str|None=getattr(plugin,"__name__",None)
+returnnameorstr(id(plugin))
+defget_plugin(self,name:str)->Any|None:
+returnself._name2plugin.get(name)
+defhas_plugin(self,name:str)->bool:
+returnself.get_plugin(name)isnotNone
+defget_name(self,plugin:_Plugin)->str|None:
+forname,valinself._name2plugin.items():
+ifplugin==val:
+returnname
+returnNone
+def_verify_hook(self,hook:HookCaller,hookimpl:HookImpl)->None:
+ifhook.is_historic()and(hookimpl.hookwrapperorhookimpl.wrapper):
+raisePluginValidationError(
+hookimpl.plugin,
+f"Plugin{hookimpl.plugin_name!r}\nhook{hook.name!r}\n"
+"historicincompatiblewithyield/wrapper/hookwrapper",
+)
+asserthook.specisnotNone
+ifhook.spec.warn_on_impl:
+_warn_for_function(hook.spec.warn_on_impl,hookimpl.function)
+notinspec=set(hookimpl.argnames)-set(hook.spec.argnames)
+ifnotinspec:
+raisePluginValidationError(
+hookimpl.plugin,
+f"Plugin{hookimpl.plugin_name!r}forhook{hook.name!r}\n"
+f"hookimpldefinition:{_formatdef(hookimpl.function)}\n"
+f"Argument(s){notinspec}aredeclaredinthehookimplbut"
+"cannotbefoundinthehookspec",
+)
+ifhook.spec.warn_on_impl_args:
+forhookimpl_argnameinhookimpl.argnames:
+argname_warning=hook.spec.warn_on_impl_args.get(hookimpl_argname)
+ifargname_warningisnotNone:
+_warn_for_function(argname_warning,hookimpl.function)
+if(
+hookimpl.wrapperorhookimpl.hookwrapper
+)andnotinspect.isgeneratorfunction(hookimpl.function):
+raisePluginValidationError(
+hookimpl.plugin,
+f"Plugin{hookimpl.plugin_name!r}forhook{hook.name!r}\n"
+f"hookimpldefinition:{_formatdef(hookimpl.function)}\n"
+"Declaredaswrapper=Trueorhookwrapper=True"
+"butfunctionisnotageneratorfunction",
+)
+ifhookimpl.wrapperandhookimpl.hookwrapper:
+raisePluginValidationError(
+hookimpl.plugin,
+f"Plugin{hookimpl.plugin_name!r}forhook{hook.name!r}\n"
+f"hookimpldefinition:{_formatdef(hookimpl.function)}\n"
+"Thewrapper=Trueandhookwrapper=Trueoptionsaremutuallyexclusive",
+)
+defcheck_pending(self)->None:
+fornameinself.hook.__dict__:
+ifname[0]=="_":
+continue
+hook:HookCaller=getattr(self.hook,name)
+ifnothook.has_spec():
+forhookimplinhook.get_hookimpls():
+ifnothookimpl.optionalhook:
+raisePluginValidationError(
+hookimpl.plugin,
+f"unknownhook{name!r}inplugin{hookimpl.plugin!r}",
+)
+defload_setuptools_entrypoints(self,group:str,name:str|None=None)->int:
+importimportlib.metadata
+count=0
+fordistinlist(importlib.metadata.distributions()):
+forepindist.entry_points:
+if(
+ep.group!=group
+or(nameisnotNoneandep.name!=name)
+orself.get_plugin(ep.name)
+orself.is_blocked(ep.name)
+):
+continue
+plugin=ep.load()
+self.register(plugin,name=ep.name)
+self._plugin_distinfo.append((plugin,DistFacade(dist)))
+count+=1
+returncount
+deflist_plugin_distinfo(self)->list[tuple[_Plugin,DistFacade]]:
+returnlist(self._plugin_distinfo)
+deflist_name_plugin(self)->list[tuple[str,_Plugin]]:
+returnlist(self._name2plugin.items())
+defget_hookcallers(self,plugin:_Plugin)->list[HookCaller]|None:
+ifself.get_name(plugin)isNone:
+returnNone
+hookcallers=[]
+forhookcallerinself.hook.__dict__.values():
+forhookimplinhookcaller.get_hookimpls():
+ifhookimpl.pluginisplugin:
+hookcallers.append(hookcaller)
+returnhookcallers
+defadd_hookcall_monitoring(
+self,before:_BeforeTrace,after:_AfterTrace
+)->Callable[[],None]:
+oldcall=self._inner_hookexec
+deftraced_hookexec(
+hook_name:str,
+hook_impls:Sequence[HookImpl],
+caller_kwargs:Mapping[str,object],
+firstresult:bool,
+)->object|list[object]:
+before(hook_name,hook_impls,caller_kwargs)
+outcome=Result.from_call(
+lambda:oldcall(hook_name,hook_impls,caller_kwargs,firstresult)
+)
+after(outcome,hook_name,hook_impls,caller_kwargs)
+returnoutcome.get_result()
+self._inner_hookexec=traced_hookexec
+defundo()->None:
+self._inner_hookexec=oldcall
+returnundo
+defenable_tracing(self)->Callable[[],None]:
+hooktrace=self.trace.root.get("hook")
+defbefore(
+hook_name:str,methods:Sequence[HookImpl],kwargs:Mapping[str,object]
+)->None:
+hooktrace.root.indent+=1
+hooktrace(hook_name,kwargs)
+defafter(
+outcome:Result[object],
+hook_name:str,
+methods:Sequence[HookImpl],
+kwargs:Mapping[str,object],
+)->None:
+ifoutcome.exceptionisNone:
+hooktrace("finish",hook_name,"-->",outcome.get_result())
+hooktrace.root.indent-=1
+returnself.add_hookcall_monitoring(before,after)
+defsubset_hook_caller(
+self,name:str,remove_plugins:Iterable[_Plugin]
+)->HookCaller:
+orig:HookCaller=getattr(self.hook,name)
+plugins_to_remove={plugforpluginremove_pluginsifhasattr(plug,name)}
+ifplugins_to_remove:
+return_SubsetHookCaller(orig,plugins_to_remove)
+returnorig
+def_formatdef(func:Callable[...,object])->str:
+returnf"{func.__name__}{inspect.signature(func)}"